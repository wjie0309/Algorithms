---
date created: 2022-04-21 21:50
---

## 引言

排序是算法中非常重要的一部分, 因为很多非常高明的算法都建立在有序数组的基础上. 同时, 在生活中, 排序的需求也屡见不鲜. 因此, 对于排序的算法的寻找和优化不断进行着, 如今有非常多的排序方法涌现, 根据不同的需求进行选择可以最大化的优化我们的算法效率.

接下来本文将介绍几种常见的排序方法.

## 选择排序

选择排序是符合人类直观思考的简单排法.

### 实现思路

1. 遍历数组寻找到最小的值.
2. 将最小的值与当前的位置的值交换.
3. 继续遍历, 不考虑前面已经排序好的最小值进行遍历.

### 时间复杂度分析

选择排序没有随机性, 不管什么情况都会遍历相同的次数. 而且都是恒等的 $O(n^2)$ 复杂度.

### 代码实现

```CPP
    for (int i = 0; i < n; i++){
        int min_pos = i;
        for (int j = i+1; j < n; j++){
            if (a[j] < a[min_pos])
            min_pos = j;

        }
        swap (a[i] , a[min_pos]);
    }
```

## 冒泡排序

冒泡排序, 顾名思义, 有点像冒泡泡的过程, 一个泡泡从水底下一点点上来, 然后最大的泡泡在最上面, 从小到大排列着.

###  实现思路

1. 对数组进行遍历, 比较当下位置和他下一个位置的数值大小.
2. 将大的向右移动, 不断遍历. 在遍历整个数组一遍之后就可以使得最大的数在最右侧.
3. 减小遍历的范围到前 `n-i+1` 个数, 继续从头开始遍历, 进行当下位置和下一个位置的值的比较.
4. 不断遍历, 最终得到排列好的数组.

### 复杂度分析

同样是一个没有最好最坏情况的算法, 复杂度同样为 $O(n^2)$ .

### 代码实现

```CPP
    for (int i = 1; i<n; i++){
        for (int j=0; j<n-i; j++){
            if (a[j] > a[j+1])
            swap(a[j], a[j+1]);
        }
    }
```

## 插入排序

插入排序也是根据算法的实现思路进行的命名, 这个算法的实现方式就像插队一样, 对一个区间内的所有人进行值的大小的比较, 谁小谁就可以排到更前面去. 然后整体的排序可以渐渐增加这个区间的长度, 从头一点一点地捋顺它. 所以只要前面"捋顺"了, 那个区间内部就是已经排好序的状态, 只需要处理从后面"插入"的新值的位置即可.

### 实现思路

1. 先从长度为 2 的区间开始, 以这个区间的最后一个值为判断基准.
2. 设立一个边界线, 比基准大的数排到线后面, 比基准小的数排到线前面.
3. 增加区间的长度, 继续进行遍历.
4. 进行循环, 全部进行边界判断, 得到成功排序的数组.

### 复杂度分析

插入排序的平均时间复杂度是 $O(n^2)$ .

- 最好情况下, 数组升序有序, 只需要进行 n-1 次元素比较操作.
- 最坏情况下, 数组降序有序, 则我们需要进行 $\frac{n(n-1)}{2}$ 次比较操作, $\frac{n(n-1)}{2}$ 次交换操作.

### 代码实现

```CPP
    for (int i = 1; i < n; i++){
        int j, tmp = a[i];
        for (j = i; j>0 && a[j-1]>tmp; j--){
            a[j] = a[j-1];
        }
        a[j] = tmp;
    }
```

## 快速排序

### 排序性能的优化
前面提到的几种基础算法都是统一的 $O(n^2)$ 时间复杂度, 而如果我们想进一步提高排序算法的性能, 该怎么做呢?

这里我们考虑一下使用 **分治** 的思想, 即把任务分解为一个或多个更小的任务, 然后分别进行解决, 这样的话能够降低每一个迭代的长度, 在多次迭代的计算机算法中, 就会产生很大的性能提升.

如果我们想办法把一个数组分成两个部分, 然后分别对两部分进行排序, 最后再组合在一起, 那么这个算法的时间复杂度就是 $O(n)$ 的遍历分成两部分, 然后两次排序即为 $2*O(n^2 /4)$ , 总共为 $O(\frac{n^2}{2} + n)$ 的复杂度, 节省了近一半的时间.

使用这样的分治思想, 我们如果在分开后进一步进行分割, 一直到分为非常小的单元, 那么就可以达到效率的最大化.

### 思路实现

1. 选择一个基准 `pivot` , 对数组进行遍历进行判断, 将大于这个基准的数放在右边, 小于该基准的数放在左边.
2. 在基准左右两侧再次重复以上算法, 进行二次分割.
3. 重复以上步骤直到新基准的两侧区间长度小于 1 .

### 复杂度分析

快速排序的算法复杂程度高度依赖选取的 `pivot` 值, 如果 `pivot` 值恰好能够二分这个数组, 那么就能够达到每次都恰好二分的效果, 这个时候效率达到 $O(nlogn)$ . 当 `pivot` 值恰好为数组的最大值或者是最小值时, 那么就会导致最坏的排序情况, 这个时候的时间复杂度与前面的简单排序方法相同为 $O(n^2)$ .

因为为了尽量避免极端值的选取给整体算法带来的影响, 我们可以通过随机选取 `pivot` 值, 从而实现**随机快速排序**, 来保证更稳定的时间复杂度.

### 代码实现

```CPP
// 选取右侧值为pivot的算法
void quick_sort(int l,int r ){
    int k = l-1, pivot = a[r];
    for (int j = l; j < r; ++j){
        if (a[j] < pivot) swap(a[j], a[++k]);
    }
    swap(a[r], a[++k]);

    if (l < k-1) quick_sort(l,k-1);
    if (k+1 < r) quick_sort(k+1,r);
}
```
#### 快速排序的多种实现方式

待补充.

## 归并排序

### 实现思路

归并排序使用了和快速排序相似的分治思想来降低时间复杂度. 而不同的是, 为了避免快速排序出现的高度依赖初始边界的选定问题, 归并排序不再用值来作为分治的边界, 而是直接在索引上进行二分来简化问题.

那么经此分离, 我们同样能一直分化到单位数组的情况, 然后进行排序, 降低迭代消耗的时间, 不过这里由于没有通过值来进行左右分化, 需要在分解后进行一个 **归并** 操作, 这也是这个排序名称的由来.

因此, 归并排序的实现可以分解为 分治 和 归并 两个部分.

1. 进行数组的分解, 通过 `mid = l + r >> 1;` 来划分数组.
2. 当数组被分解到最小单元后, 开始进行判断, 每一对分解的数组进行比对, 然后完成局部排序并归并到上一级.
3. 归并时进行判断, 由于基准 `mid` 的定义规则, 前半部分长度大于等于后半部分长度, 因此可以给出判断条件: 当右侧数组为空, 或者两数组都不为空时左数组对应索引值等于右数组对应索引值时, 左数组的值先排列进去, 否则右数组的值先排列进去.
4. 从最底层向上迭代归并, 最后完成整体数组的归并.

和快速排序不同的是, 归并排序还是一个 **稳定排序** .

***稳定性**描述的是对于有重复元素的序列, 如果排序前后, **重复的元素相对位置不变**. 这种叫做**稳定算法**, 否则就是不稳定.*

### 复杂度分析

归并排序的算法实现中稳定地分为两个部分, 分治和归并, 这两个部分的复杂度分别为 O(logn) 和 O(n) ;

因此, 归并排序的时间复杂度稳定的为 O(nlogn) .

不过对应的, 归并排序的空间复杂度相对更高, 因为需要使用一个额外的数组来进行值的储存, 空间复杂度为 o(2n) .

### 代码实现

```CPP
int a[100000], b[100000];

void merge(int l, int r){
	for (int i = 1; i <= n; i++) b[i] = a[i];

	int mid = l + r >> 1;
	int i = l, j = mid + 1;
	for (int k = l; k <= r; k++){
		if (j>r || i<=mid && a[i]<a[j])  a[k] = b[i++];
		else  a[k] = b[j++];
	}
}

void merge_sort(int l, int r){
	if (l>=r) return; // 边界判定
	int mid = l+r >> 1;
	merge_sort(l, mid);
	merge_sort(mid+1, r);
	
	merge(l, r);
}
```

## 计数排序

前面的所有排序方法都是基于比较实现的排序算法. 其实在**数字的变化区间不是特别大**的情况下, 我们可以通过统计每一个数出现的次数, 然后依次将它们排列出来, 从而实现排序算法. 从这两句话中就能看出来, 在不存在相对比较的情况下, 如果数字的变化区间不大, 这个算法将会比比较实现的所有算法拥有更高的效率.

### 实现思路

1. 统计每个数字的出现次数.
2. 从小到大枚举值的范围, 对 cnt 求前缀和记为 sum .
3. 从后往前枚举每个元素 `a[i]` , 分配其在排序后数组中的索引 `idx[i]` 的值为 `sum[a[i]]` , 也就是其应该排列的新位置, 然后将 `sum[a[i]]` 减少 1 ,以此更新排列的位置. 
4. *从后往前遍历是为了保持算法的稳定性* .

### 复杂度分析

计数排序的时间复杂度是 $O(n+X)$ , 其中 X 为数字的变化区间, 例如 1- 100 的情况下 X 为 100 . 因此, 在 X 相对不大的情况下, 计数排序的时间复杂度可以视为 $O(n)$ .

### 代码实现

