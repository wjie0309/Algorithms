---
date created: 2022-04-26 13:28
---

# 基本概念

## 数据结构的基本操作

对于一个数据结构而言, 基本的操作是通用的, 分别为:

- 创建
- 清除
- 插入
- 删除
- 搜索
- 更新
- 访问
- 遍历

## 复杂度

复杂度分为时间复杂度T(n)与空间复杂度S(n)
一般更多的考虑时间复杂度的计算

时间复杂度的常见类型：O(1), O(n), O(logn), O(nlogn), O(n^2), O(n^3), O(2^n), O(n!)
_复杂度从小到大排列_

logn是怎么来的？

- 一般通过二分类型算法计算时会出现对数形式的复杂度

## 最大子列和问题

求一个数组中连续的子列最大值

```
#01-复杂度1 最大子列和问题  
num = int(input())  
ls = [int(x) for x in input().split()] #列表推导式  
ThisSum = MaxSum = 0  
for i in range(num):  
    ThisSum += ls[i]  
    if(ThisSum > MaxSum):  
        MaxSum = ThisSum  
    elif(ThisSum < 0):  
        ThisSum = 0  
print(MaxSum)
```

复杂度O(n)
时间复杂度小但是损失更多的精度和信息

二分查找
从一半分开，不断二分，小于0直接淘汰，大于0则取+=ThisMax
复杂度O(nlogn)

# 线性表

## 线性结构

除了头元素和尾元素, 每一个元素都只有唯一的前驱和后继.

## 数组

- 特性：易查找，难增删

结构:
头数组: L[0]
尾数组: L[Max-1]
空间以及逻辑相连

数组的增加：

- 先找到增加的位置K
- 从最后开始依次进行`L.data[j+1]=L.data[j]`
- 在第k个位置上添加
- 长度加一

数组的删除

- 找到删除的位置K
- 从K后一位开始进行`L.data[j-1]=L.data[j]`
- 长度减一

## 链表

- 特性：易增删，难查找

结构

- 数据域：储存元素
- 指针域：指向下一个结构的数据域`L.next`
- 由一个头指针，中间指针和一个尾指针组成，尾指针指向None

链表的长度
从头指针开始遍历，一直到检测到None为止求计数器的长度

链表的查找

- 序列查找
- 值查找

链表的插入

- 找到插入位置K
- 设新指针s

```
	s.next=L.next
	L.next=s
```

- 链表长度+1

链表的删除

- 找到删除位置前一个结点K-1
- 令K位置指针为s`s=p.next`
- `p.next=s.next`
- 链表长度-1

广义链表: 解决二元方程

- 数据域不再单纯为元素, 可以指向新的指针

十字链表

- e.g. 稀疏矩阵的表示等
- 由**head和term项**组成
  - head: 两个指针域分别指向同一行和同一列(head项的同行/列有一组即全是head), 没有数据域
  - term: 两个指针域分别指向同一行和同一列, 且为**循环列表**: 最后一项将会指向head项. 数据域中为行列及当下元素的信息
- **入口指针**是term项格式, 行列为矩阵的总行列数, 元素为非0项的数量

![[Pasted image 20220130100933.png]]

双向链表

- 由两个指针域和一个数据域构成, 可以向前及向后寻找指针

循环链表

## 栈

具有一定操作约束的线性表: 只在栈顶做插入和删除

- 结构

	- 栈顶`Top`
	- 后入先出

### 栈的操作实现

- 栈的初始化

- 堆栈的 `Push`

	- Top指针向上移动
	- Top指针指向的栈顶输入新元素

- 堆栈的 `Pop`

	- 返回Top指针的元素
	- Top指针向下移动
	- 原来的元素删除

- 判定是否为空 `isempty()`

### 栈的数组实现

一个数组可以储存两个堆栈(正序+倒序)
建立两个指针`Top1, Top2`
使用`Tag==1||2`

Push

- 先判断数组是否满`Top2-Top1==1`
- 判断Tag来决定为哪个链表的操作
- `Data[++Top1] = item`
- `Data[--Top2] = item`

只储存一个栈则只需要判定 `Top == maxSize - 1` .

Pop

- 先判断Tag决定哪个链表的操作
- 判断是否为空栈
  - `if Top1==-1`
  - `if Top2==Max`
- `return data[Top1--]`
- `return data[Top2++]`



### 栈的链表实现

一个链表储存一个堆栈
链表的堆栈不用判断满栈

结构

- 头指针为一个空指针s
- 空指针s指向下一个即为堆栈栈顶

Push

- 新结点指向s.next, 头指针s指向新结点FirstCell
- `FirstCell.next = s.next`
- `s.next = FirstCell`

Pop

- 判断空栈`s.next==Null`
  - 将栈顶命名为t
- `s.next=t.next`
- `return t`
- `free(t)`

```CPP
node *tmp = top_p;
x = tmp->data;
top_p = top_p->next;
delete tmp;
return x;
```

### 应用: 使用栈实现递归结构

用栈储存递归的函数, 在调用子函数时入栈, 调用完成后出栈, 从而实现递归函数.

### 应用: 表达式求值

中缀表达式转后缀表达式

- 数字直接输出,符号入栈
- 遇到优先级低于栈内符号时,栈内符号出栈直到优先级小于栈内符号为止
- 遇见右括号一直出栈到遇见左括号为止

后缀表达式求值

- 数字入栈
- 遇见符号最近入栈的两个数字进行运算再次入栈
- 左括号进栈, 右括号出现时让左括号出栈, 期间的数字进行运算

## 队列

队列: 先入先出

限定查找, 

结构

- 队列, front指针, rear指针
- front指针指向第一个数的前一项, rear指针正好指向最后一个数

### 实现操作

- 队列的入队

- 判断满队

	- `rear++`
	- `p[rear] = item`

- 队列的出队

- 判断空队

	- `front++`
	- `return p[front]`

- 读队头元素

- 判断队列满和队列空

	常规情况下, 使用了循环队列之后, 队列满和队列空将会是一个状态, 无法进行直观判断. 因此我们可以通过牺牲一个单元来达到这个效果.

	牺牲一个单元, 规定 `front` 不储存数据, 仅作标记用, 真正的队头元素存放在 ` 后一个单元.

### 队列的数组实现

数组可以实现**循环队列**的形式, 通过取余算法实现循环利用空数组

```
int front=rear=-1 # 初始化头尾指针,初始值都为-1

# 入队
if (rear+1%)%Max == front:
{
	return 'queue is full'
}
p[rear] = item
rear = (rear+1)%Max

# 出队
if (front == rear):
{
	return 'queue is empty'
}
e = p[front]
front = (front+1)%Max
return e
```

### 队列的链表实现

链表不需要在意队列满队的判断
链表的头结点充当front指针,尾结点充当rear指针

```
# 入队 在队尾插入e
s.data = e
s.next = NULL
rear.next = s
rear = s # 将rear指针后移一格

# 出队 删除后一个结点
p = front.next
if rear==front:
	rear = front = NULL
else
	front = front.next
e = p.data
return e
free(p)
```

# 树

## 查找

查找问题大类分为**静态查找**和**动态查找**
静态查找一般使用数组进行实现, 因为不需要进行数据的增删, 避开了数组的劣势

### 静态查找

#### 顺序查找

引入**哨兵**的概念: 将`L[0]`看作一个哨兵, 不用于储存数据, 而是储存需要查找的数字值
通过这种方法, 可以减少判断语句(之前如果0号也是需要判断是否符合查找值以及是否遇见数组上下限)

#### 二分查找

时间复杂度O(logN)
设立二指针从中间开始判断

```
K
left = 1
right = len(A)-1
while right>=left:
	mid = (left+right)//2
	if A[mid]>K:
		left = mid+1
	elif A[mid]<K:
		right = mid-1
	else:
		return mid
return -1
```
