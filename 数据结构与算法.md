---
date created: 2022-04-26 13:28
---

# 基本概念

## 数据结构的基本操作

对于一个数据结构而言, 基本的操作是通用的, 分别为:

- 创建
- 清除
- 插入
- 删除
- 搜索
- 更新
- 访问
- 遍历

## 复杂度

复杂度分为时间复杂度T(n)与空间复杂度S(n)
一般更多的考虑时间复杂度的计算

时间复杂度的常见类型：O(1), O(n), O(logn), O(nlogn), O(n^2), O(n^3), O(2^n), O(n!)
_复杂度从小到大排列_

logn是怎么来的？

- 一般通过二分类型算法计算时会出现对数形式的复杂度

## 最大子列和问题

求一个数组中连续的子列最大值

```
#01-复杂度1 最大子列和问题  
num = int(input())  
ls = [int(x) for x in input().split()] #列表推导式  
ThisSum = MaxSum = 0  
for i in range(num):  
    ThisSum += ls[i]  
    if(ThisSum > MaxSum):  
        MaxSum = ThisSum  
    elif(ThisSum < 0):  
        ThisSum = 0  
print(MaxSum)
```

复杂度O(n)
时间复杂度小但是损失更多的精度和信息

二分查找
从一半分开，不断二分，小于0直接淘汰，大于0则取+=ThisMax
复杂度O(nlogn)

# 线性表

## 线性结构

除了头元素和尾元素, 每一个元素都只有唯一的前驱和后继.

## 数组

- 特性：易查找，难增删

结构:
头数组: L[0]
尾数组: L[Max-1]
空间以及逻辑相连

数组的增加：

- 先找到增加的位置K
- 从最后开始依次进行`L.data[j+1]=L.data[j]`
- 在第k个位置上添加
- 长度加一

数组的删除

- 找到删除的位置K
- 从K后一位开始进行`L.data[j-1]=L.data[j]`
- 长度减一

## 链表

- 特性：易增删，难查找

结构

- 数据域：储存元素
- 指针域：指向下一个结构的数据域`L.next`
- 由一个头指针，中间指针和一个尾指针组成，尾指针指向None

链表的长度
从头指针开始遍历，一直到检测到None为止求计数器的长度

链表的查找

- 序列查找
- 值查找

链表的插入

- 找到插入位置K
- 设新指针s

```
	s.next=L.next
	L.next=s
```

- 链表长度+1

链表的删除

- 找到删除位置前一个结点K-1
- 令K位置指针为s`s=p.next`
- `p.next=s.next`
- 链表长度-1

广义链表: 解决二元方程

- 数据域不再单纯为元素, 可以指向新的指针

十字链表

- e.g. 稀疏矩阵的表示等
- 由**head和term项**组成
  - head: 两个指针域分别指向同一行和同一列(head项的同行/列有一组即全是head), 没有数据域
  - term: 两个指针域分别指向同一行和同一列, 且为**循环列表**: 最后一项将会指向head项. 数据域中为行列及当下元素的信息
- **入口指针**是term项格式, 行列为矩阵的总行列数, 元素为非0项的数量

![[Pasted image 20220130100933.png]]

双向链表

- 由两个指针域和一个数据域构成, 可以向前及向后寻找指针

循环链表

## 栈

具有一定操作约束的线性表: 只在栈顶做插入和删除

- 结构

	- 栈顶`Top`
	- 后入先出

### 栈的操作实现

- 栈的初始化

- 堆栈的 `Push`

	- Top指针向上移动
	- Top指针指向的栈顶输入新元素

- 堆栈的 `Pop`

	- 返回Top指针的元素
	- Top指针向下移动
	- 原来的元素删除

- 判定是否为空 `isempty()`

### 栈的数组实现

一个数组可以储存两个堆栈(正序+倒序)
建立两个指针`Top1, Top2`
使用`Tag==1||2`

Push

- 先判断数组是否满`Top2-Top1==1`
- 判断Tag来决定为哪个链表的操作
- `Data[++Top1] = item`
- `Data[--Top2] = item`

只储存一个栈则只需要判定 `Top == maxSize - 1` .

Pop

- 先判断Tag决定哪个链表的操作
- 判断是否为空栈
  - `if Top1==-1`
  - `if Top2==Max`
- `return data[Top1--]`
- `return data[Top2++]`



### 栈的链表实现

一个链表储存一个堆栈
链表的堆栈不用判断满栈

结构

- 头指针为一个空指针s
- 空指针s指向下一个即为堆栈栈顶

Push

- 新结点指向s.next, 头指针s指向新结点FirstCell
- `FirstCell.next = s.next`
- `s.next = FirstCell`

Pop

- 判断空栈`s.next==Null`
  - 将栈顶命名为t
- `s.next=t.next`
- `return t`
- `free(t)`

```CPP
node *tmp = top_p;
x = tmp->data;
top_p = top_p->next;
delete tmp;
return x;
```

### 应用: 使用栈实现递归结构

用栈储存递归的函数, 在调用子函数时入栈, 调用完成后出栈, 从而实现递归函数.

### 应用: 表达式求值

中缀表达式转后缀表达式

- 数字直接输出,符号入栈
- 遇到优先级低于栈内符号时,栈内符号出栈直到优先级小于栈内符号为止
- 遇见右括号一直出栈到遇见左括号为止

后缀表达式求值

- 数字入栈
- 遇见符号最近入栈的两个数字进行运算再次入栈
- 左括号进栈, 右括号出现时让左括号出栈, 期间的数字进行运算

## 队列

队列: 先入先出

限定查找, 

结构

- 队列, front指针, rear指针
- front指针指向第一个数的前一项, rear指针正好指向最后一个数

### 实现操作

- 队列的入队

- 判断满队

	- `rear++`
	- `p[rear] = item`

- 队列的出队

- 判断空队

	- `front++`
	- `return p[front]`

- 读队头元素

- 判断队列满和队列空

	常规情况下, 使用了循环队列之后, 队列满和队列空将会是一个状态, 无法进行直观判断. 因此我们可以通过牺牲一个单元来达到这个效果.

	牺牲一个单元, 规定 `front` 不储存数据, 仅作标记用, 真正的队头元素存放在 ` 后一个单元.

### 队列的数组实现

数组可以实现**循环队列**的形式, 通过取余算法实现循环利用空数组

```
int front=rear=-1 # 初始化头尾指针,初始值都为-1

# 入队
if (rear+1%)%Max == front:
{
	return 'queue is full'
}
p[rear] = item
rear = (rear+1)%Max

# 出队
if (front == rear):
{
	return 'queue is empty'
}
e = p[front]
front = (front+1)%Max
return e
```

### 队列的链表实现

链表不需要在意队列满队的判断
链表的头结点充当front指针,尾结点充当rear指针

```
# 入队 在队尾插入e
s.data = e
s.next = NULL
rear.next = s
rear = s # 将rear指针后移一格

# 出队 删除后一个结点
p = front.next
if rear==front:
	rear = front = NULL
else
	front = front.next
e = p.data
return e
free(p)
```

# 树

## 查找

查找问题大类分为**静态查找**和**动态查找**
静态查找一般使用数组进行实现, 因为不需要进行数据的增删, 避开了数组的劣势

### 静态查找

#### 顺序查找

引入**哨兵**的概念: 将`L[0]`看作一个哨兵, 不用于储存数据, 而是储存需要查找的数字值
通过这种方法, 可以减少判断语句(之前如果0号也是需要判断是否符合查找值以及是否遇见数组上下限)

#### 二分查找

时间复杂度O(logN)
设立二指针从中间开始判断

```
K
left = 1
right = len(A)-1
while right>=left:
	mid = (left+right)//2
	if A[mid]>K:
		left = mid+1
	elif A[mid]<K:
		right = mid-1
	else:
		return mid
return -1
```

## 树的定义

- 对于任何一个非空树, 具有以下性质:
	- 有一个 root , 用 r 表示
	- 其余结点可被划分为 m 个不相交的子集, 且子集依然满足树的定义, 为原来树的子树 (subtree) .

- 延伸的定理
	- 子树不相交
	- 除了根结点外, 每个结点有且仅有 1 个父结点.
	- 一颗 N 个结点的树有 N-1 条边
	- 树是连接每个结点的最简结构

- 基本术语
	- 结点的度: 一个结点的子树个数
	- 树的度: 树的所有结点中最大的度数
	- Leaf: 度为 0 的结点
	- Parent (父结点)
	- Child (子结点)
	- Sibling (兄弟结点): 同一父结点的各个结点
	- 路径: 从结点 $n_1$ 到 $n_k$ 的遍历过程经历的结点序列, 路径长度即为过程中边的个数
	- Ancester: 某一结点到 root 的路径上所有结点都为此结点的 祖先结点 
	- Descendent: 某一结点子树的所有结点
	- level (层次) : root 为 1 层, 所有结点的 Level 都是其父结点的 level + 1
	- 深度: 树的最大层次

## 树的表示

### 链表实现

怎么能最优化实现？

#### Child-Sibling 表示法

![](https://s1.vika.cn/space/2022/06/06/adcad9f093fd4912960f7a3b5771258f)

每一个结点储存两个指针, 一个指向第一个子结点, 一个指向下一个兄弟结点.

## 二叉树

### 二叉树的定义

- 度为 2 的树, 是树状结构中的最重要的内容, 熟悉二叉树可以泛化到其他形式的树.

- 一个有穷的结点集合
- 二叉树的子树有左右之分

![](https://s1.vika.cn/space/2022/06/06/75bf6e5c16604feea3facce8984b5d39)

### 特殊的二叉树

- 斜二叉树: 只往一边倒, 形成线性结构
- 完美二叉树 (满二叉树)
- 完全二叉树: 编号顺序和完美二叉树完全相同的树

### 二叉树的性质

- 一个二叉树第 i 层的最大结点数为: $2^{i-1}$ 
- 深度为 k 的树最大结点数为 $2^k -1$ 
- 对于任意非空二叉树, $n_0$ 表示叶结点的个数, $n_2$ 是度为 2 的结点的非叶结点个数, 那么两者必满足关系 $n_2 = n_0 + 1$

### 二叉树的操作

 1. 判断空
 2. 遍历
	 1. 先序遍历: 根, 左子树, 右子树
	 2. 中序遍历: 左子树, 根, 右子树
	 3. 后序遍历: 左子树, 右子树, 根
	 4. 层次遍历: 从上到下, 从左到右
 3. 创建二叉树

### 二叉树的存储结构

#### 顺序存储结构

完全二叉树: 可以通过从上到小, 从左到右的方式进行存储

非根结点的父结点序数为 `[i/2]`
结点的子结点分别为: `2i`, `2i+1` . 当这个数大于 n 的时候, 则不存在子结点

对于一般二叉树, 则可以通过补全为完全二叉树的方法, 来使用顺序存储. 但这会造成空间上的浪费.

#### 链表存储

定义 TreeNode, 包含 val, left, right.

二叉树的链表实现可以不使用 Child-Sibling 方法, 可以直接指向两个子结点.

用结构数组表示树: 静态链表

如何在储存结构中判断根的位置: 除了根外, 所有的结点都会在过程中被指向, 因此值中没有的序列就是根的位置.

### 二叉树的遍历

#### 先序遍历, 中序遍历, 后序遍历

通过递归实现先序遍历很轻松, 首先访问 root 结点, 然后对左子树递归, 右子树递归.

中序和后序遍历都类似实现

```Python
def PretOrderTraversal(BT -> BinTree):
	print(BT.val)
	PostOrderTraversal(BT.left)
	PostOrderTraversal(BT.right)
```

注意这种遍历的编号, 是先把左边的树遍历到底, 然后再从底层子树逐渐向右遍历结点.

![](https://s1.vika.cn/space/2022/06/06/d1a5c70ea9d9401aa09caf767370e615)

#### 非递归遍历实现

直接使用堆栈使用

- 堆栈实现中序遍历

	1. 遇到一个结点就压栈, 并遍历左子树
	2. 当左子树遍历结束时, 从栈顶弹出并访问它
	3. 然后按其右指针去遍历访问右子树

#### 层序遍历

- 二叉树遍历的核心问题: 二维结构的线性化

##### 队列实现

1. 出队并访问结点
2. 输出结点的值
3. 将结点的左右指针入队

#### 树的确定

由中序序列和任一序列可以唯一地确定一个树的结构

## 二叉搜索树

### 二叉搜素树的性质

每一个结点, 右子结点比本身大, 左子结点比本身小.

### 二叉搜索树的功能

- 查找
	- `Find(x, BST)`
	- `FindMin(BST)`
	- `FindMax(BST)`
- 插入 `Insert(x, BST)`
- 删除 `Del(x, BST)`

树结构的实现一般都可以通过迭代和递归两种方法实现, 递归常用的是尾递归形式, 这两者的运算逻辑是很相似的.

#### 查找

- 迭代实现

	1. 访问结点, 判断结点值和 x 的大小
	2. 如果结点值大, 就访问 node.right
	3. 如果结点值小, 就访问 node.left
	4. 遇到 None 退出遍历

- 递归实现

	1. 如果结点空, 返回 null
	2. 结点比较小, 在右边递归
	3. 结点比较大, 在左边递归

FindMin 和 FindMax 只需要一直向左或者向右遍历到底即可

#### 插入

过程和查找的实现过程有一点类似, 一般通过递归实现

1. 遍历树结点
2. 当 x 比树结点大时, 向右遍历
3. 比树结点小时, 向左遍历
4. 在到叶结点后, 插入在叶结点下

#### 删除

- 删除的为叶结点: 直接删除, 然后修改父结点位置
- 只有一个子结点: 就将父结点和子结点相连
- 有两个子结点的情况: 用左子树的最大值或右子树的最小值替代

### 平衡二叉树

- 不同的插入次序, 会导致搜索树的深度不同, 以及 ASL (平均查找长度) 不同. 因此最大高度越小的搜索树, 就会有更高的搜索效率.

- 平衡因子 (BF) : 左子树高度 - 右子树高度

- 平衡二叉树 (AVL 树)

	- 空树
	- 任一结点的平衡因子不超过 1 , $|BF(T)| \leq 1$ 
	- 注意: 仍为二叉搜索树

- 平衡二叉树的最小结点数

$$n_h = n_{h-1} + n_{h-2} + 1$$

可以通过对此数列求和, 可证 n 结点的平衡二叉树的最小高度 $h = O(log_2 n)$ .

### 平衡二叉树的调整

在插入新结点使得平衡二叉树被破坏的情况下, 可以调整二叉树使之回归平衡二叉树的状态

#### RR 旋转

![](https://s1.vika.cn/space/2022/06/09/5f7170f801e5441f8ded814915af9874)

#### LL 旋转 

![](https://s1.vika.cn/space/2022/06/09/dd54c4b096ac40aab4ba7891f81fd419)

#### LR 旋转

#### RL 旋转

旋转的核心关键是保证二叉搜索树的性质不变, 通过调整变动的三个结点结构, 来实现新的二叉搜索树的平衡.

三个结点中值在中间的当新的根结点, 然后重新处理叶结点的父结点, 使之依然满足二叉搜索树的性质