---
date created: 2022-04-17 15:22
date updated: 2022-04-17 16:00
---

## 枚举

枚举法是一种通过枚举所有解, 并设定一个检查条件来检查是否有符合条件的解出现, 然后将合理的解计入答案的方法.

### 枚举的优化

直接的暴力枚举时间复杂度相当高, 因此我们的计算速度会受到很大的影响. 因此在进行枚举算法的时候, 我们有一些方法能够适当降低算法的复杂度.

- 能算则算

  可以通过一些计算来减少不必要的枚举, 从而适量降低时间复杂度.

  ```
    e.g. 如在进行一个平面方块集合上正方形的枚举时, 可以通过正方形两边相同的数学性质直接通过一个顶点确定另外一个顶点可能出现的所有位置, 这样可以避免大量重复的循环.
  ```

- 能存则存

  通过储存更多的信息, 可以避免重复的计算. 这是一个经典的利用空间复杂度交换时间复杂度的方法.

  **前缀和** 是一种非常常见的算法, 通过提前储存信息来避免重复计算, 大大提高计算效率.

  通过声明一个前缀和数组来储存之前已经计算过的前缀和.

  ```
    通过这种方式, 可以直接计算第 i 项到第 j 项之间的数之和之类的问题.
  ```

  _杂谈: 可以发现在很多地方都有这种 "世界是公平的." 的感觉, 不会无端地出现单纯更优的解决方案, 一方面的优化总是伴随着另外一个方面的牺牲. 就像学物理的时候滑轮一样, 要么省力费距离, 要么省距离费力. 我们只是需要在这其中的得失中寻找我们最追求的东西._

## 子集枚举

在一些场合, 我们经常被要求能够枚举出一个集合的所有子集. 子集枚举的实现可以借助 **比特串** 的方式来进行子集的的表示和枚举.

### 使用比特串表示

一个比特串例如 `01000101` 可以通过每一位上的数字是 0 还是 1 来记录一个数组的子集信息. 通过这种方式, 我们就可以把一个子集的信息通过一串数字简洁地表示出来.

### 子集的枚举

要想枚举一个用比特串表示的子集, 则要找到合理的方法来读取字符串每一位数上的数字. 这里我们可以通过一些简单的 **位运算** 实现.

- `&` 运算, 获取最后一位上的数字信息

  通过 `&` 运算, 输出 1 的话说明最后一位是 1 , 否则说明是 0 .  这个方法同样可以用来判断一个数字的奇偶性.

  ```
  nums & 1;
  ```

- 左移/右移

	一种二进制数据的操作方式, 可以使整体的比特串向左移或者向右移 n 位, 相当于十进制乘以 2 或是除以 2 .

	```
	nums << n;
	nums >> n;
	```

通过这两种运算, 我们可以先对数据进行右移操作, 使得目标位为最后一位, 然后进行 & 运算来得到该位置的值.

这种过程因为在枚举的时候需要遍历比特串, 而大小为 n 的数组需要一个长度为 n 的比特串来表示, 也就是说在遍历的时候要进行 $2^n$ 次遍历, 然后在单个循环中还需要对整个比特串的每一位数进行获取值的操作, 总共的时间复杂度为 `O(n*2^n)` .

### 递归子集枚举

通过递归来进行子集的枚举, 这种方法只需要 `O(2^n)` 的复杂度, 因此比直接使用比特串进行子集枚举更快.

## 排列枚举

### 排列

排列是将数组按照一定的顺序排成一列的表述方式.

常常使用 **字典序** 的方式来进行不同数据的顺序比较.

#### 字典序

- 从第一个字母/数字开始进行比较, 如果在第 i 个位置满足,  i 以前的每一个字母都相同, 且 i 没有超过两个序列的长度, 而第 i 个字母的字典序不等的情况下, 若 `a[i] < b[i]` , 那么则说 `a < b` .
- 如果从第一个字母一直到最后一个都相等的话, 则比较两个序列的长度, 长度更长的数据比较大.
- 如果所有元素相等且长度相等, 则 `a = b` .

####  STL 和 next_permutation

`next_permutation` 一共有三个参数, 分别为头指针, 尾指针以及比较函数. 头指针和尾指针的常用表达方式为 `数组名 + idx值`

```CPP
id = [1,2,3];
next_permutation(id, id+3);
```

`next_permutation` 可以将数组指定区域排列为字典序更大一点 (也就是说是在所有的排列方式中按字典序大小升序迭代生成) 的排列, 并返回一个布尔值来表示当前数组能否排列为一个字典序更大的排列方式.

值得注意的是, 当已经是最大了的情况下, 则会将其排列为字典序最小的排列方式.

复杂度为 `O(n!)` .

### 递归枚举

同样通过递归的思想, 实现树状结构的回溯和遍历, 可以进行枚举.