---
date created: 2022-04-17 14:45
---

## 算法的复杂度

在我们描述一个算法的时候, 经常可以通过这个算法的运行时间以及运行的过程中消耗的资源(或者说占用内存) 来评估一个算法的效率.

因此我们引入了 **时间复杂度** 以及 **空间复杂度** 的概念. 其中在现实中更经常考虑的是时间复杂度. 因为时间上的消耗在当今的社会上更加昂贵.

## 空间复杂度

空间复杂度的计算比较简单, 也不那么经常被考虑. 最典型的使用空间复杂度的场合就是计算数组储存的大小.

定义一个二维数组一般需要 `O(N^2)` , 一维数组则是 `O(N)` .

## 时间复杂度

### 时间复杂度

对于时间复杂度的计算, 可以简单的看一个算法运行过程中实际上要进行的操作步数一共有多少.

同时, 对于同数量级的操作数量, 为了便于计算和表达, 我们都统称为一个相同的时间复杂度, 用大写的 O 来标记.

```
例如, 一个简单的单循环列出从 1 到 n 的所有数字的过程的时间复杂度为 O(n) .
```

一般语句的复杂度还是比较容易进行判断的, 只需要观察算法中的循环是几重循环就比较方便可以看出来. 不过对于一些稍微特殊一点的算法, 就需要注意一下了, 接下来将介绍几个需要注意的情况.

### 递归算法的复杂度

递归算法的本质是实现二叉树类型的算法结构, 而观察递归算法的复杂度就需要观察这个二叉树的节点数量与算法中本身定义的 `n` 的关系了.

- 斐波那契数列

  斐波那契数列的实现是很经典的递归算法, 而这个算法的时间复杂度是 `O(2^n)` .

  ```CPP
  def Fibonacci(n){
  	if (!n) return 0;
  	else if (n==1) return 1;
  	
  	int ret;
  	ret = Fibonacci(n-1) + Fibonacci(n-2);
  }
  ```
	这种递归我们可以看见, 在为 n 的结点下, 需要进行两个操作, 然后这两个操作又分别需要进行两个操作, 以此类推... 不难看出, 这个算法的时间复杂度为指数等级的.

- 复杂度仅为 `O(log n)` 的递归算法

	那么就所有的递归算法都一定是高时间复杂度的吗, 实则不然. 这个关键在于调用本函数时改变的参数是什么数量级的. 如果每次都调用 `n-1` , 那么至少也需要运行 n 次这个函数, 则自然不可能会有低于 `O(n)` 的算法出现.

	而其他的调用方法可能可以简化这种固化的复杂度, 通过减少需要调用己身的次数来实现. 比如说调用 `f(n/2)` , 则可以实现 `O(log n)` 时间复杂度的算法.

